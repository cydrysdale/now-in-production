<!doctype html>
<html lang="en">

<head>
  <script>
    try {
      const t = localStorage.getItem('theme');
      if (t === 'dark' || t === 'light') document.documentElement.setAttribute('data-theme', t);
    } catch {}
  </script>
  <meta charset="utf-8" />
  <title>Demystifying AI: Stepping into the LLM Kitchen</title>
  <link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png">
  <link rel="icon" href="../images/favicon.ico" type="image/x-icon">
  <link rel="manifest" href="../site.webmanifest">
  <meta name="description" content="A practical guide to how LLMs work—using a pixel kitchen/restaurant sim metaphor to teach prompts, context windows, tools, QA, and agent workflows." />
  <meta name="keywords" content="LLMs, large language models, how ChatGPT works, tokens, context window, attention, prompting, prompt engineering, decoding, temperature, top-p, hallucinations, AI tools, citations, verification, QA checklist, agents" />
  <meta name="guide:category" content="AI" />
  <meta name="guide:updated" content="2026-02-23" />
  <link rel="canonical" href="https://cydrysdale.github.io/now-in-production/guides/how-llms-work.html">
  <meta name="robots" content="index,follow">
  <meta name="author" content="Chris Yasuda Drysdale">
  <meta name="format-detection" content="telephone=no" />
  <meta property="og:type" content="article">
  <meta property="og:title" content="Demystifying AI: Stepping into the LLM Kitchen">
  <meta property="og:description" content="A playful, practical guide for using LLMs reliably: tickets, prep counters, tools, expo pass QA, and station workflows." />
  <meta property="og:image" content="https://cydrysdale.github.io/now-in-production/images/LLM-context-window.png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:url" content="https://cydrysdale.github.io/now-in-production/guides/how-llms-work.html">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=VT323&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fredericka+the+Great&amp;display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/css/style.css">
  <link rel="stylesheet" href="../assets/css/tokens.css">
  <script src="../assets/js/core.js" defer></script>
  <script src="../assets/js/widgets.js" defer></script>
  <script src="../assets/js/tokens.js" defer></script>
  <style>
    :root { --bg-light: url('../../images/pxArt2.png'); }
    :root[data-theme="dark"] { --bg-dark: url('../../images/pxArtDark2.png'); }

    .badge {
      display: inline-block;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid var(--borderDark);
      background: var(--card2);
      font-size: .85rem;
      color: var(--muted);
      vertical-align: middle;
    }

    .hero {
      display: grid;
      grid-template-columns: 1.15fr .85fr;
      gap: 16px;
      align-items: start;
    }

    @media (max-width: 980px) {
      .hero { grid-template-columns: 1fr; }
    }

    .kicker { font-size: 1.05rem; }
    .note { font-size: .95rem; color: var(--muted); }

    .truth {
      margin: 10px 0 16px;
      padding: 10px 12px;
      border: 1px solid var(--borderLight);
      border-left: 4px solid var(--accent);
      border-radius: 10px;
      background: linear-gradient(30deg, var(--callout), var(--card));
      font-style: italic;
    }

    .truth strong { font-style: normal; }

    .diagram {
      border: 1px solid var(--borderDark);
      border-radius: 14px;
      background: var(--card);
      overflow: hidden;
    }

    .diagram figcaption {
      padding: 10px 12px;
      border-top: 1px solid var(--borderDark);
      color: var(--muted);
      font-size: .95rem;
    }

    .diagram img { width: 100%; height: auto; display: block; }

    .sandbox-input.wide { width: min(760px, 100%); }
    textarea.sandbox-input { width: min(760px, 100%); min-height: 110px; }

    .roster {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 14px;
    }

    @media (max-width: 1100px) { .roster { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 700px) { .roster { grid-template-columns: 1fr; } }

    .roster .chef {
      border: 1px solid var(--borderDark);
      border-radius: 14px;
      background: var(--card);
      overflow: hidden;
    }
    .roster .chef .body { padding: 12px 12px 2px; }
    .roster .chef img { width: 100%; height: auto; display: block; }
    .roster .chef h3 { margin-top: 0; }

    .quest input[type="checkbox"] { transform: translateY(1px); margin-right: 8px; }
    .quest li { margin-bottom: 8px; }

    #pgChoices { display: flex; gap: 8px; padding: 8px 0; }
    #pgChoices button { flex: 1; min-width: 80px; }
    #pgChoices button:disabled { cursor: default; }

    .counter-bar {
      display: flex;
      gap: 4px;
      padding: 8px;
      border: 1px solid var(--borderDark);
      border-radius: 10px;
      background: var(--card2);
      margin-bottom: 10px;
      min-height: 48px;
      align-items: stretch;
    }

    .counter-slot {
      flex: 1;
      padding: 8px 2px;
      border-radius: 6px;
      text-align: center;
      font-size: .75rem;
      line-height: 1.2;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 0;
      word-break: break-word;
    }

    .counter-slot.empty { border: 1px dashed var(--borderDark); }

    .counter-slot.filled {
      border: 1px solid var(--borderDark);
      background: var(--card);
    }

    .counter-slot.rules {
      border: 1px solid var(--accent);
      background: var(--accent);
      color: #fff;
      font-weight: bold;
    }

    #hqChoices { display: flex; gap: 8px; padding: 8px 0; }

    /* Chef Select */
    .select-screen { display: flex; flex-direction: column; gap: 12px; }
    .portrait-row { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; }
    @media (max-width: 600px) { .portrait-row { grid-template-columns: repeat(3, 1fr); } }

    .portrait {
      aspect-ratio: 1;
      border: 2px solid var(--borderDark);
      border-radius: 8px;
      background: var(--card2);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: .8rem;
      font-weight: bold;
      color: var(--muted);
      transition: border-color 0.15s, box-shadow 0.15s;
    }

    .portrait:hover { border-color: var(--accent); }
    .portrait.active { border-color: var(--accent); box-shadow: 0 0 0 2px var(--accent); }
    .portrait img { width: 100%; height: 100%; object-fit: cover; border-radius: 6px; }

    .chef-panel {
      display: grid;
      grid-template-columns: 240px 1fr;
      border: 1px solid var(--borderDark);
      border-radius: 14px;
      background: var(--card);
      overflow: hidden;
    }

    @media (max-width: 700px) { .chef-panel { grid-template-columns: 1fr; } }

	    .chef-art {
	      background: var(--card2);
	      display: flex;
	      align-items: flex-end;
	      justify-content: center;
	    }

	    .chef-art img { height: auto; display: block; }
	    .chef-art img.chef-art-img { width: 100%; }
	    .chef-art img.chef-art-placeholder { width: 100%; opacity: .7; }
	    .chef-info { padding: 16px 20px; }
	    .chef-name { font-size: 1.3rem; font-weight: bold; margin: 0 0 2px; }
	    .chef-title-label { color: var(--accent); font-weight: bold; font-size: .9rem; margin-bottom: 10px; }
	    .chef-bio { font-size: .9rem; line-height: 1.5; margin-bottom: 14px; }
	    .chef-stats { display: flex; flex-direction: column; gap: 3px; }
    .stat-row { display: flex; align-items: center; gap: 8px; font-size: .85rem; }
    .stat-label { font-weight: bold; width: 32px; font-size: .8rem; }
    .stat-stars { color: var(--accent); letter-spacing: 2px; }
  </style>
</head>

<body>
  <a class="skip-link" href="#content">Skip to content</a>
  <header>
    <div class="header-inner">
      <img src="../images/apple-touch-icon.png" width="60px" style="display: inline-block; margin-right: 10px;"
        alt="site logo" />
      <div id="top" class="title-block">
        <h1>Demystifying AI: Stepping into the LLM Kitchen</h1>
        <div class="sub">A basic guide on how LLMs work for the extremely nerdy</div>
      </div>
      <div class="header-actions">
        <div class="theme-toggle" style="scale: 75%;">
          <input id="themeSwitch" type="checkbox" role="switch" aria-checked="false" aria-label="Toggle dark mode">
          <label for="themeSwitch">
            <span class="track" aria-hidden="true"></span>
            <span class="thumb" aria-hidden="true">
              <span class="icon sun">&#9788;</span>
              <span class="icon moon">&#9789;</span>
            </span>
          </label>
        </div>
        <div class="toc-mobile">
          <button id="tocToggle" aria-expanded="false" aria-controls="tocList">☰ Inventory</button>
          <nav id="tocList" class="toc" aria-label="On this page"></nav>
        </div>
      </div>
    </div>
  </header>

  <div class="page">
    <aside class="toc-desktop">
      <nav class="toc" aria-label="On this page"></nav>
    </aside>
    <main id="content">

      <section>
        <h2>What this guide is for</h2>

        <div>
            <p class="kicker">
              You’ve probably used ChatGPT, Claude, Gemini, or Copilot—and perhaps you even went a little crazy and tried Grok. You’ve seen AI do impressive things. You also may have seen it confidently state that there are two R's in strawberry.
            </p>
            <p>
              While this guide won’t make you an AI researcher, it will give you the information you need to:
            </p>
            <ul>
              <li>Write better prompts that get more predictable, verifiable results</li>
              <li>Understand why AI “forgets,” drifts, or hallucinates</li>
              <li>Run multi-step workflows that produce usable results</li>
            </ul>

            <h3>The AI restaurant sim</h3>
            <p>
              Throughout this guide, we'll be using a kitchen sim metaphor to help reinforce each concept:
            </p>
            <ul>
              <li>The <strong>Cook (AI model)</strong> works quickly, but can only create using the ingredients and tools in front of them.</li>
              <li>Your <strong>Order Ticket (prompt)</strong> is the objective, rules, and output format: what to cook, substitutions/allergies, and how to plate it.</li>
              <li>The <strong>Prep Counter (context)</strong> is everything the chef has right in front of them to work with: attachments or links submitted with the prompt.</li>
              <li>Your <strong>Inventory (context window)</strong> is limited. The counter space gets too crowded, older items might fall off.</li>
              <li><strong>Tools (calendar, spreadsheet, search)</strong> determine if the chef has access to a pantry for extra ingredients, cookbooks to research recipes, or use an appliance like a brulee torch.</li>
            </ul>

            <div class="truth"><strong>Kitchen truth:</strong> Our chefs may be brilliant, but they have a limited attention span—if it’s not on the ticket or the counter, it doesn’t exist.</div>
        </div>
      </section>

      <section>
        <h2>Mise en Place: How LLMs Generate Text (and Why the Prompt Matters)</h2>
          <p>
            Everyone around you has probably been raving about AI recently. Your social media feed is full of influencers showing how AI sends them a text every morning with a daily to do list, plans all their meals, and reads them a bedtime story at night. 
          </p>
            <div class="grid callout">
              <div>
                <p>
                  So, you decide to try it out by asking for something simple, it answers confidently:
                </p>
                <div class="code" data-label="Grok">
                  <div><p><strong>Who would win in a fight in 2025? Elon Musk or Mike Tyson?</strong></p></div>

                  <div class="code-type animate">Mike Tyson packs legendary knockout power that could end it quick, but Elon's relentless endurance from 100-hour weeks and adaptive mindset outlasts even prime fighters in prolonged scraps. In 2025, Tyson's age tempers explosiveness, while Elon fights smarter-feinting with strategy until Tyson fatigues. Elon takes the win through grit and ingenuity, not just gloves.<span class="cursor animate">_</span></div>
                </div>
              </div>
              <div class="mini-widget">
                <p id="tokenParagraph">
                  This isn't necessarily because that AI model is faulty or inferior to another model that gave you a better answer. It could be a result of a bad prompt or improper utilization of that particular model. Which is why it's important to understand how LLMs work and how they generate text.
                <br><br>
                  It's best to think of an LLM as a chef or line cook at a restaurant. It doesn’t cook the whole dish in one step. It adds one ingredient (small chunk of text called a <strong>token</strong>) at a time. After each ingredient, it reviews what’s available on the <strong>prep counter (context)</strong> and the <strong>order ticket (prompt)</strong>, then asks: “Given what I can see right now, what’s the most plausible next ingredient?”
                </p>
                <button class="sandbox-btn" id="toggleTokens" type="button" aria-pressed="false" aria-controls="tokenParagraph">
                  Highlight tokens
                </button>
              </div>
        </div>

        <div class="truth"><strong>Kitchen truth:</strong> Tokens aren't just how the model reads and generates text—they also determine pricing, latency, and maximum output length.</div>

        <h3>Your phone already does this (badly)</h3>
        <p>
          You've actually seen this mechanism before: start typing a text message and your phone suggests the next word. Type "I went to the" and it offers "store" | "park" | "hospital." That's next-word prediction—called an <strong>n-gram</strong>—the same core idea behind every LLM.
        </p>
        <p>
          The difference? Your phone's keyboard uses a simple lookup: "what word most commonly follows these last one or two words?"
          It doesn't know you were planning a beach trip three messages ago. It doesn't understand context—it understands <strong>frequency</strong>.
        </p>

        <div class="sandbox-card" id="predictGame">
          <label class="sandbox-label"><strong>Try it: guess the next word like an n-gram</strong></label>
          <p id="pgProgress" class="note" style="margin:0 0 4px"></p>
          <div class="code" data-label="Complete the sentence:">
            <div class="code-type" id="pgSentence" style="min-height:1.4em;white-space:normal"></div>
          </div>
          <div id="pgChoices"></div>
          <div id="pgReveal" class="callout" style="display:none" aria-live="polite"></div>
          <button id="pgNext" class="sandbox-btn" type="button" style="display:none">Next round</button>
        </div>

        <h3>The upgrade: looking at the whole counter</h3>
        <p>
          LLMs use the same core mechanic—predict the next token—but instead of glancing at the last word or two, they look at everything currently on the counter (the full context window). That's why an LLM can connect "surgeon" to "scalpel" even when they're sentences apart.
        </p>

        <div class="truth"><strong>Kitchen truth:</strong> Your phone keyboard is a cook who only looks at the last ingredient added. An LLM is a cook who glances at the whole counter—but it's still cooking one ingredient at a time.</div>

        <details class="tip">
          <summary><strong>Power-up (optional): N-grams—the phone's cheat sheet</strong></summary>
          <p>
            An <strong>n-gram</strong> is a sequence of <em>n</em> consecutive words. Your phone's predictions are powered by tables of these:
          </p>
          <ul>
            <li><strong>Unigram (n = 1):</strong> single-word frequency. "The" is one of the most common English words, so it gets suggested constantly.</li>
            <li><strong>Bigram (n = 2):</strong> word pairs. After "of the" → "most" | "best" | "world." After "going to" → "be" | "the" | "get."</li>
            <li><strong>Trigram (n = 3):</strong> three-word chains. "One of the" → "most." "I want to" → "go" | "be" | "know."</li>
          </ul>
          <p>
            The phone stores a frequency table of these sequences (often personalized to your texting habits) and picks the highest-scoring match. The window is tiny—usually 1–3 words—so it has no ability to track meaning, themes, or instructions from earlier in the conversation.
          </p>
          <p>
            Try this: open your phone, type a word, then keep tapping the middle suggestion 20 times. You'll get a grammatically plausible but meaningless sentence—that's n-gram prediction running on autopilot with no broader understanding.
          </p>
        </details>

        <h3>Same prompt, different response</h3>
        <p>
          You may have noticed that entering the same prompt into the same LLM can produce different answers. This is because when the model generates text, it considers lots of possibilities for the next word (token) and scores them. Then the system <strong>chooses one</strong> based on a setting referred to as the <strong>temperature</strong> which controls how strongly it sticks to the top choice vs. how willing it is to take a less-likely option.
        </p><p>  
          Imagine ordering chocolate chip cookies for dessert—a temperature of 0 means the chef follows the standard recipe exactly as written. A temperature of 1 means the chef will put its own spin on the recipe, so you might get oatmeal chocolate chip or browned butter pecan, but you're still getting cookies. Now a temperature of 2 means the chef can get truly creative and you might end up receiving spaghetti and watermelon balls with a chocolate marinara, topped with a candied fennel garnish.
        </p>
        <div class="grid">
          <div class="callout">
            <h3 style="margin-top:0">Standard recipe</h3>
            <p style="margin:0">Stable and repeatable (nearly the same each run).</p>
          </div>
          <div class="callout">
            <h3 style="margin-top:0">Chef’s special</h3>
            <p style="margin:0">Varied and improvisational (poetic or pure nonsense).</p>
          </div>
        </div>

        <div class="truth"><strong>Kitchen truth:</strong> Most models you'll encounter have a set temperature, but some models do allow you to adjust it yourself.</div>

        <div class="sandbox-card" id="tempDemo">
          <label for="tempSlider" class="sandbox-label"><strong>Try it: drag the temperature slider to complete the sentence</strong></label>
          <div style="display:flex; align-items:center; gap:12px">
            <span class="note">Standard recipe</span>
            <input id="tempSlider" type="range" min="0" max="100" value="0" step="1"
              style="flex:1; min-width:120px" aria-label="Temperature slider from 0 to 2" />
            <span class="note">Chef's special</span>
          </div>
          <div style="text-align:center; margin:6px 0">
            <span class="badge" id="tempValue">Temperature: 0.0</span>
          </div>
          <div class="code" data-label="LLM output:">
            <div class="code-type" style="white-space:normal">The sky is<span id="tempOutput">...</span><span class="cursor animate">_</span></div>
          </div>
        </div>

        <h3>Why prompts matter more than people expect</h3>
        <p>
          The model’s default job is to produce a coherent continuation of whatever you put in front of it. If your prompt is vague, “coherent” often means it picks an interpretation it thinks is most likely and commits—hello, <strong>chocolate spaghetti with watermelon</strong>. If your prompt is specific (gluten-free vegan chocolate chip cookies with cinnamon, no fruit or nuts), “coherent” shifts towards what you actually want.
        </p>

        <details class="tip">
          <summary><strong>TL;DR</strong></summary>
          <ul>
            <li>Your order ticket (prompt) tells the chef (LLM model) what you want.</li>
            <li>The chef then cooks your order one ingredient (token) at a time.</li> 
            <li>A more specific order ticket doesn't make the chef better at cooking—it provides the chef more context to make your order the way you envisioned.</li>
            <li>Different chefs can cook the same order in vastly different ways. If you want the standard recipe, Copilot might be your best bet; but if you're feeling adventurous and have a steel gut, Grok is ready with the Chef's special.</li>
          </ul>
        </details>
      </section>
      <section>
        <h2>The Prep Counter: Context Windows, Drift, “Forgetting,” and the Dreaded Hallucination</h2>

        <p>
          In the last section we established that our LLM chef generates text one token at a time by scanning everything on its prep counter. But here's the catch: <strong>that counter is not infinite</strong>. Every model has a fixed amount of counter space called its <strong>context window</strong>, measured in tokens. Once the counter is full, something has to go.
        </p>

        <h3>Counter space: bigger isn't always better</h3>
        <p>
          Context windows have gotten dramatically larger over the past few years. Early GPT models had roughly 4,000 tokens of counter space—about three pages of text. Today, some models advertise windows of 128K, 200K, or even 1 million tokens. That sounds like the chef upgraded from a cutting board to a full commercial kitchen island. And to help our chef work quickly and efficiently, all that additional space came with new cookbooks and countertop appliances that also use that new space.
        </p>
        <p>
          But here's what the marketing doesn't tell you: <strong>more counter space also means more stuff for our chef to keep track of</strong>. So our chef might remember what was on the counter when they started cooking and they can easily see the last few items that were added, but everything in between is slowly being buried or shoved to the side. This is where <strong>attention</strong> comes into play.
        </p>

        <h3>Attention—how LLMs look at the whole counter</h3>
        <div class="grid">
          <div>
            <p>
              In n-gram prediction, the model only sees a fixed window of 1–3 words. LLMs replace that tiny window with a mechanism called <strong>attention</strong>. For each new token the model is about to generate, attention assigns a <strong>relevance score</strong> between that position and every other token already on the counter. Think of it as the cook glancing back across all the ingredients and deciding which ones matter <em>right now</em>. This is the core of the <strong>transformer</strong> architecture (the "T" in GPT). There is a tradeoff though: attention across all tokens is computationally expensive and scales with the size of the context—which is one reason context windows have limits and longer prompts cost more.
            </p>
          </div>
          <!--Image Comparison Slider-->
          <div>
            <figure dir="rtl">
              <p class="image-compare" role="img" tabindex="0" aria-label="Interactive comparison of LLM context windows with and without attention highlighting." aria-description="Two overlaid images are revealed by a slider. One shows an LLM context window with attention weights highlighted, illustrating how the model focuses on relevant tokens. The other shows the same context window without highlighting, representing raw token storage.">
                <span>
                  <img src="../images/LLM-context-window-attn.png" alt="" aria-hidden="true">
                  </span>
                  <img src="../images/LLM-context-window.png" alt="" aria-hidden="true">
              </p>
            </figure>
          </div>
        </div>
        <details class="tip">
          <summary><strong>Power-up (optional): The mechanics of attention</strong></summary>
          <p>
            <strong>Attention</strong> is the Transformer mechanism that lets each token <strong>pull in and mix information from other tokens</strong> in the context. It acts like differentiable retrieval: “given what I need at this position, which earlier tokens are most relevant?”
          </p>
        
          <p>
            Mechanically, the model projects token representations <code>X</code> into <strong>queries, keys, values</strong>:
          </p>
        
          <ul>
            <li><code>Q</code>: what this token is looking for</li>
            <li><code>K</code>: how each token can be matched</li>
            <li><code>V</code>: the information to combine</li>
          </ul>
        
          <p>
            It computes relevance with <strong>scaled dot products</strong>, normalizes with <strong>softmax</strong>, then mixes values:
          </p>
        
          <pre><code>Attn(Q, K, V) = softmax((QKᵀ / √d_k) + mask) V</code></pre>
        
          <p>
            In GPT-style LLMs, a <strong>causal mask</strong> blocks attention to future tokens so generation is valid.
          </p>
        
          <p>
            LLMs use <strong>multi-head attention</strong> so different heads can learn different dependency patterns in parallel, and they inject <strong>positional information</strong> (e.g., RoPE/relative encodings) so attention is sensitive to word order. During generation, <strong>KV caching</strong> stores past keys/values to avoid recomputing them each step. Full attention scales <strong>quadratically</strong> with context length (<code>O(n^2)</code>), which is why long contexts are expensive.
          </p>
        </details>

        <h3>Drift: when the model gradually stops following the rules</h3>
        <p>
          In long AI conversations, you may see the model follow your instructions perfectly at first—then slowly begin to bend them. For example: your prompt says “use bullet points only,” it complies, and ten messages later it starts writing paragraphs. That gradual loss of adherence is known as <strong>drift</strong>.
        </p>
        <p>
          Drift happens because the model is generating each reply based on the entire visible conversation. As the thread grows, your original instructions become a smaller and less prominent part of the context compared to newer messages, new subgoals, and recent wording. The model also tends to match the most recent style and priorities unless constraints are kept explicit.
        </p>
        <p>
          To reduce drift, periodically <strong>restate the constraints that matter</strong>, preferably as a short, consistent rule block (e.g., “Format: bullets only. Length: &lt;150 words. Tone: direct.”). This keeps the rules salient and reduces the chance they’re implicitly overridden by newer content.
        </p>

        <h3>“Forgetting”: the counter has an edge</h3>
        <p>
          Drift is gradual—your instructions are still technically on the counter, just buried. <strong>Forgetting</strong> is what happens when the conversation exceeds the context window entirely. At that point, the oldest messages literally fall off the edge of the counter. The chef doesn't know they ever existed.
        </p>
        <p>
          This is not a bug. It's a hard physical constraint called <strong>context overflow</strong>—like a counter that can hold a maximum of 10 ingredients. Adding an 11th ingredient knocks ingredient one to the floor. Most LLM interfaces handle this silently: they drop or summarize the oldest messages to make room, and the model has no idea anything was removed.
        </p>
        <p>
          This is why you might have a conversation where the AI researched a song title for you in message three, and by message 40 it has no memory of that song existing. It simply slid off the counter.
        </p>

        <div class="grid">
          <div class="callout">
            <h3 style="margin-top:0">Drift</h3>
            <p style="margin:0">Your instructions are still on the counter but buried under newer context. The chef <em>could</em> see them—it's just focused elsewhere.</p>
          </div>
          <div class="callout">
            <h3 style="margin-top:0">Forgetting</h3>
            <p style="margin:0">Your instructions have fallen off the counter entirely. The chef <em>cannot</em> see them—they no longer exist in its world.</p>
          </div>
        </div>

        <div class="sandbox-card" id="overflowDemo">
          <label class="sandbox-label"><strong>Try it: fill the prep counter until something falls off</strong></label>
          <p id="ofStatus" class="note" style="margin:0 0 4px"></p>
          <div class="counter-bar" id="ofBar"></div>
          <div style="display:flex; gap:8px">
            <button id="ofAdd" class="sandbox-btn" type="button">Send message</button>
            <button id="ofReset" class="sandbox-btn" type="button">Reset</button>
          </div>
          <div id="ofReveal" class="callout" style="display:none" aria-live="polite"></div>
        </div>

        <div class="truth"><strong>Kitchen truth:</strong> Many LLMs allow you to group chats into projects. This allows you to specify rules that apply to everything inside that project which can help prevent drift and forgetting.</div>

        <details class="tip">
          <summary><strong>Power-up (optional): What actually happens when context overflows</strong></summary>
          <p>
            Different platforms handle overflow differently, and most don't tell you when it's happening:
          </p>
          <ul>
            <li><strong>Truncation:</strong> The oldest messages are silently dropped. This is the simplest approach—first in, first out.</li>
            <li><strong>Sliding window:</strong> The system keeps your original system prompt pinned at the top and drops the oldest conversation turns from the middle. This preserves your initial instructions but loses early conversation context.</li>
            <li><strong>Summarization:</strong> Some systems use a secondary model to compress older messages into a short summary before dropping them. The chef gets a sticky note that says “earlier we discussed X” instead of the full conversation—better than nothing, but details get lost.</li>
          </ul>
          <p>
            None of these are perfect. The practical takeaway: for important, multi-step work, don't rely on a single marathon conversation. Break it into shorter sessions and carry forward the key context yourself.
          </p>
        </details>

        <h3>Hallucination: the chef that never says “I don’t know”</h3>
        <p>
          This is the big one—the behavior that makes people distrust AI entirely, or worse, trust it when they shouldn’t.
        </p>
        <p>
          A <strong>hallucination</strong> is when a model produces a claim that sounds confident and well-formed, but isn’t actually supported by the information it has. It might invent a study, fabricate a quote, misstate a law, or confidently “fill in” a missing detail that was never verified.
        </p>
        <p>
          Under the hood, the core engine is still a next-token generator: given the text in front of it, it predicts what a good-sounding continuation looks like. If it’s operating in a <em>closed-book</em> mode (no tools, no retrieval), it isn’t checking a database or consulting the internet—it’s pattern-completing from what it learned during training and what you’ve provided in the chat. When the real answer isn’t present, the model can generate something that <em>resembles</em> an answer without actually being one.
        </p>
        <p>
          Modern systems complicate this in a good way: many LLM products can now <strong>look things up</strong> using search, retrieval (RAG), or other tools, and that can dramatically reduce hallucinations—<em>when the tool is actually used</em> and the retrieved sources are reliable. But it doesn’t make the problem disappear. The model can still misread what it finds, summarize incorrectly, mix together multiple sources, cite the wrong thing, or—if lookup fails or isn’t available—quietly fall back to fluent guessing.
        </p>
        <p>
          Back in the kitchen: sometimes the chef can step off the line and check the cookbook, call the supplier, or peek in the walk-in—that’s browsing and
          retrieval. It helps. But what if the cookbook is missing a page, the supplier gives bad info, or the chef is rushing? And if the chef has been trained to always serve <em>something</em>, they’ll improvise rather than admit they don't know how to make your order. So, you still get a plate that <em>looks</em> right but it might not be edible.
        </p>

        <details class="tip">
          <summary><strong>Power-up (optional): Why can't they just… not hallucinate?</strong></summary>
          <p>
            This is one of the most common questions people ask. Part of the answer is architectural, and part of it is incentives.
          </p>   
          <p>
            At the core, an LLM generates text by predicting likely next tokens from patterns learned during training. It isn’t running a “truth check” as it writes, and it doesn’t automatically ground claims in a source of record. So it can produce a fluent sentence that <em>sounds</em> right even when it isn’t.
          </p>     
          <p>
            It’s also worth separating <strong>uncertainty</strong> from <strong>honesty</strong>. The model may be internally “unsure” in the sense that multiple continuations are plausible, but unless the system is explicitly designed to surface that uncertainty, it still has to pick one concrete continuation—and concrete answers often come out sounding confident by default.
          </p>      
          <p>
            On top of that, many chat models are <strong>tuned to be helpful and decisive</strong>. Depending on how they’re trained and deployed, they may be implicitly (or explicitly) discouraged from responding with “I don’t know.” If the system rewards always producing an answer—or penalizes refusals and hedging—the model learns a style that fills gaps with plausible detail instead of stopping short.
          </p>
          <p>
            Researchers mitigate hallucination in layers: retrieval-augmented generation (RAG) can ground responses in provided sources; preference tuning (often called RLHF) can teach models to hedge, refuse, or ask for clarification; and some products add post-generation verification (citations, consistency checks, tool-based fact checking). These help a lot, but they don’t fully eliminate hallucination—because the underlying generator is still optimizing for “plausible continuation,” not “guaranteed truth.”
          </p>
        </details>

        <h3>Why hallucinations are hard to spot</h3>
        <p>
          The dangerous part isn't that LLMs make things up—it's that the made-up content is <strong>structurally indistinguishable</strong> from the accurate content. The model uses the same confident tone, the same formatting, the same grammatical polish whether it's giving you a real fact or an invented one. There's no italics for “I'm guessing here” and no red flag emoji for “I made this up.”
        </p>
        <p>
          This means verification is not optional. It's not a nice-to-have for cautious people—it's a core part of using these tools responsibly. If the model gives you a statistic, a name, a date, a quote, a URL, or a citation: <strong>check it</strong>. Not because the model is bad, but because it was never designed to be a fact database. It was designed to produce plausible text.
        </p>

        <div class="grid">
          <div class="callout">
            <h3 style="margin-top:0">Likely reliable</h3>
            <ul style="margin:0">
              <li>Well-known facts</li>
              <li>General explanations of common concepts</li>
              <li>Code patterns for popular frameworks</li>
              <li>Structural tasks (formatting, summarization, rewriting)</li>
            </ul>
          </div>
          <div class="callout">
            <h3 style="margin-top:0">Verify before trusting</h3>
            <ul style="margin:0">
              <li>Specific statistics, dates, or numbers</li>
              <li>Direct quotes attributed to real people</li>
              <li>Citations, URLs, or references to studies</li>
              <li>Niche or recent facts</li>
            </ul>
          </div>
        </div>

        <div class="sandbox-card" id="hallucinationQuiz">
          <label class="sandbox-label"><strong>Try it: spot the hallucination</strong></label>
          <p id="hqProgress" class="note" style="margin:0 0 4px"></p>
          <div class="code" data-label="AI-generated claim:">
            <div class="code-type" id="hqClaim" style="min-height:1.4em;white-space:normal"></div>
          </div>
          <div id="hqChoices">
            <button id="hqFact" class="sandbox-btn" type="button">Fact</button>
            <button id="hqMyth" class="sandbox-btn" type="button">Myth</button>
          </div>
          <div id="hqReveal" class="callout" style="display:none" aria-live="polite"></div>
          <button id="hqNext" class="sandbox-btn" type="button" style="display:none">Next claim</button>
        </div>

        <details class="tip">
          <summary><strong>TL;DR</strong></summary>
          <ul>
            <li>The <strong>context window</strong> (prep counter) is finite and every model has a hard limit.</li>
            <li><strong>Attention</strong> is how the LLM decides what is most relevant when looking at everything in the context window.</li>
            <li><strong>Drift</strong> happens when your original instructions get drowned out by a growing conversation. Restate key rules periodically.</li>
            <li><strong>Forgetting</strong> happens when conversation history exceeds the context window and older messages are silently dropped. Break long tasks into shorter sessions.</li>
            <li><strong>Hallucinations</strong> happen because the model predicts plausible text, not verified facts. It will never say “I don't know”—it will always serve <em>something</em>.</li>
            <li>Verification is not optional. If the output includes specific facts, check them before trusting them.</li>
          </ul>
        </details>
      </section>

      <section>
        <h2>The Order Ticket: Why One Prompt Is Never Enough</h2>

        <p>
          You now understand how the chef cooks (one token at a time) and how the prep counter works (finite, prone to drift and forgetting). The third piece of the puzzle—and the one you have the most control over—is the <strong>order ticket</strong> itself: your prompt.
        </p>
        <p>
          Most guides on prompt engineering focus on clever tricks: magic phrases, special formatting, secret keywords that unlock better output. Some of those tips are useful. But the single most important skill isn't writing one perfect prompt—it's understanding that <strong>one prompt is almost never enough</strong>.
        </p>

        <h3>"Make me something good"</h3>
        <p>
          Walk into a restaurant and tell the chef "make me something good." You'll get a dish. It might even be decent. But it probably won't be what you had in mind, because the chef had to guess your preferences, dietary restrictions, mood, and expectations—all from four words.
        </p>
        <p>
          That's what most people do with AI. They type a single prompt, get a mediocre result, and conclude the tool isn't very useful. But the problem wasn't the chef—it was the ticket. A vague order produces a generic dish. Every time.
        </p>

        <div class="truth"><strong>Kitchen truth:</strong> "Make me something good" will always get you the chef's default. If you don't specify, the chef fills in every blank with whatever seems most likely—and "most likely" is rarely the same as "what you actually wanted."</div>

        <p>Now, "make me something good" isn't necessarily a bad prompt—in fact, open-ended prompts can be useful early on, when you’re exploring and need inspiration or a brainstorming partner. Once you do have a clear sense of what you want (and what you don’t), it’s often worth starting a new chat with a fresh prompt that states those requirements explicitly. This keeps outdated assumptions and abandoned ideas out of the context window—and makes it easier for the model to stay aligned as the conversation grows.</p>

        <h3>One ticket is never enough</h3>
        <p>
          Here's what experienced AI users understand that casual users don't: <strong>the first response is just a draft, not a finished product</strong>. The real work starts after you read what comes back.
        </p>
        <p>
          Think about how you'd approach the same task without AI. If you needed to write a project proposal, you wouldn't sit down and produce a polished final version in one pass. You'd outline, draft, re-read, cut what doesn't work, restructure, get feedback, and revise. The process is iterative because good work is iterative.
        </p>
        <p>
          AI is the same. The best results come from a <strong>draft-and-revise loop</strong>:
        </p>
        <ol>
          <li><strong>First pass:</strong> Give the model a prompt. Read what comes back. Don't accept or reject—<em>evaluate</em>.</li>
          <li><strong>Identify gaps:</strong> What's wrong? What's missing? What did it misinterpret? What's actually good that you want to keep?</li>
          <li><strong>Refine:</strong> Update your prompt with more specific instructions, corrections, or constraints. Run it again.</li>
          <li><strong>Repeat</strong> until the output matches what you need—or until you realize you need to restructure your approach entirely.</li>
        </ol>
        <p>
          This is not a sign of failure. A chef expects to taste and adjust seasoning. A designer expects to iterate on mockups. A writer expects to revise drafts. The tool didn't fail—you're just not done yet.
        </p>

        <div class="sandbox-card" id="iterationDemo">
          <label class="sandbox-label"><strong>Try it: watch a prompt improve through revision</strong></label>
          <p id="itProgress" class="note" style="margin:0 0 4px"></p>
          <div class="code" id="itPromptBlock" data-label="Order ticket (draft 1):">
            <div class="code-type" id="itPrompt" style="white-space:normal"></div>
          </div>
          <div class="code" data-label="Chef produces:">
            <div class="code-type" id="itOutput" style="white-space:normal"></div>
          </div>
          <div id="itNotice" class="callout" aria-live="polite"></div>
          <button id="itNext" class="sandbox-btn" type="button">Next revision</button>
        </div>

        <h3>Why AI can't replace experience</h3>
        <p>
          There's a persistent fantasy that AI will let anyone produce expert-level work without expert-level knowledge. Write legal contracts without understanding law. Debug code without knowing how to program. Design systems without production experience. Just type what you want and let the AI handle the rest.
        </p>
        <p>
          This gets the relationship exactly backwards. AI is an <strong>amplifier</strong>, not a replacement. It amplifies what the user already knows. An experienced developer using AI can produce code faster because they can read the output, spot the bugs, evaluate the architecture, and give precise feedback when something is wrong. A non-developer using the same AI will accept buggy code, miss security vulnerabilities, and have no way to evaluate whether the output actually works—because they don't know what to look for.
        </p>
        <p>
          Back in the kitchen: an experienced foodie can taste a dish and say "needs acid, too much salt, the protein is overcooked." That feedback is specific and the chef can adjust precisely. Someone who's never cooked might say "it tastes weird" or, worse, not notice anything is wrong at all.
        </p>

        <div class="truth"><strong>Kitchen truth:</strong> AI amplifies your vision—it doesn't replace it. If you can't tell a good dish from a bad one, a chef can't help you.</div>

        <h3>What goes into a good prompt</h3>
        <p>
          There's no single "correct" prompt format, but effective prompts tend to include the same kinds of information:
        </p>
        <ul>
          <li><strong>Role / context:</strong> Who is this for? "You're writing for a technical audience" or "explain like I'm a 5-year-old" gives the model a frame to work within.</li>
          <li><strong>Task:</strong> What specifically needs to be done? Not "help me with my proposal" but "write a 300-word introduction arguing that AI-powered rocks are the way of the future."</li>
          <li><strong>Constraints:</strong> What should the model avoid or limit? "No jargon," "under 500 words," "don't include personal opinions."</li>
          <li><strong>Format:</strong> How should the output be structured? "Use bullet points," "respond as a table with columns for X, Y, and Z."</li>
          <li><strong>Examples:</strong> If you have a specific style or pattern in mind, show it. Models are excellent at pattern-matching from examples.</li>
        </ul>
        <p>
          You don't need all five for every prompt. A quick question doesn't need role and format specifications. But for anything substantial—drafting content, analyzing data, generating code—the more of these fields you fill in, the closer the first draft will be to what you actually need, and the fewer revision cycles it will take.
        </p>

        <div class="grid">
          <div class="callout">
            <h3 style="margin-top:0">Vague prompt</h3>
            <p style="margin:0">"Write me an email about the project update."</p>
          </div>
          <div class="callout">
            <h3 style="margin-top:0">Specific prompt</h3>
            <p style="margin:0">"Write a 3-paragraph email to my team summarizing this week's iRock Pro MAX+ progress. Tone: professional but warm. Include: API migration is 80% complete, QA starts Monday, need 3 volunteers for user testing by EOD Friday. End with bullet-point action items."</p>
          </div>
        </div>

        <div class="truth"><strong>Kitchen truth:</strong> A specific ticket doesn't make the chef more talented—it just stops the chef from guessing. Every detail you provide is one fewer gap the model fills with its own assumptions.</div>

        <details class="tip">
          <summary><strong>TL;DR</strong></summary>
          <ul>
            <li>A single prompt rarely produces a finished result. Treat the first response as a rough draft and iterate.</li>
            <li>The revision loop—prompt, evaluate, refine, repeat—is the normal workflow, not a sign of failure.</li>
            <li>AI amplifies expertise. Professionals get better results because they can evaluate and correct the output. Novices can't tell when the output is wrong.</li>
            <li>Good prompts include context, a specific task, constraints, output format, and examples when relevant.</li>
            <li>You don't need prompt tricks. You need the same skills you'd use doing the work manually: clear thinking, critical evaluation, and willingness to revise.</li>
          </ul>
        </details>
      </section>

      <section>
        <h2>Running the Line: Workflows, Agents, and the Expo Pass</h2>

        <p>
          You can now write a solid order ticket and iterate until the dish is right. But some orders are too big for a single ticket—no matter how refined it is. Asking one prompt to research, analyze, draft, format, and fact-check a complex deliverable is like asking one cook to simultaneously run the grill, the sauté station, and the dessert counter. It might work for a grilled cheese. It won't work for a five-course meal.
        </p>
        <p>
          This is where <strong>station workflows</strong> come in: breaking a complex task into a sequence of focused steps, each with its own prompt, its own inputs, and a clear handoff to the next.
        </p>

        <h3>Why single prompts break down</h3>
        <p>
          For simple tasks—a quick summary, a format conversion, a short email—a single prompt works fine. But as complexity grows, three problems compound:
        </p>
        <ul>
          <li><strong>Context overload:</strong> The more you ask for in one prompt, the more the model has to juggle. Instructions get buried, priorities blur, and the output becomes a mediocre average of everything you asked for instead of being excellent at any one thing.</li>
          <li><strong>No checkpoints:</strong> If step 2 goes wrong in a 5-step process and you only see the final output, you can't tell where things derailed. You receive a bad dish and no way to diagnose where the kitchen went wrong.</li>
          <li><strong>Drift at scale:</strong> Long, complex prompts fill the context window faster. The model starts losing track of constraints from earlier in the prompt—the same drift problem discussed earlier, compressed into a single turn.</li>
        </ul>

        <div class="truth"><strong>Kitchen truth:</strong> A single cook juggling every station simultaneously doesn't produce excellent dishes—if you're lucky, they'll produce mediocre ones. Complex tasks need a line of cooks, not a single hero.</div>

        <h3>The kitchen line</h3>
        <p>
          Professional kitchens don't have one person doing everything. They run a <strong>line</strong>: a sequence of specialized stations, each responsible for one part of the meal. Prep handles ingredients. Grill handles proteins. Sauté handles sides. Pastry handles dessert. The <strong>expediter</strong> (expo) sits at the end, inspecting every plate before it goes out.
        </p>
        <p>
          The same model works for AI. Instead of one massive prompt, you break the task into stations:
        </p>
        <ol>
          <li><strong>Each station has one job.</strong> "Clean up these notes." "Extract the action items." "Draft the summary." Not all three at once.</li>
          <li><strong>Each station gets focused input.</strong> The output of the previous station becomes the input for the next—not the entire conversation history.</li>
          <li><strong>You check at each handoff.</strong> Before passing output to the next station, review it. Catch errors now, not three stations later.</li>
        </ol>
        <p>
          This works whether you're running each station manually (copying output into a new prompt) or using tools that chain steps automatically. The principle is the same: <strong>focused steps with verified handoffs</strong>.
        </p>

        <div class="sandbox-card" id="workflowDemo">
          <label class="sandbox-label"><strong>Try it: step through a station workflow</strong></label>
          <p class="note" style="margin:0 0 4px">Task: turn rough meeting notes into a stakeholder-ready summary</p>
          <p id="wfProgress" class="note" style="margin:0 0 4px"></p>
          <div class="code" id="wfPromptBlock" data-label="Station 1 — prompt:">
            <div class="code-type" id="wfPrompt" style="white-space:normal"></div>
          </div>
          <div class="code" data-label="Station output:">
            <div class="code-type" id="wfOutput" style="white-space:normal"></div>
          </div>
          <div id="wfNotice" class="callout" aria-live="polite"></div>
          <button id="wfNext" class="sandbox-btn" type="button">Next station</button>
        </div>

        <div class="truth"><strong>Kitchen truth:</strong> The line works because each station has one job and one handoff. The moment you ask one station to do too many things, you've lost the advantage of having a line.</div>

        <h3>The expo pass: nothing leaves without a check</h3>
        <p>
          In a professional kitchen, no plate reaches the table without passing the <strong>expo</strong>—the expediter who checks every dish for accuracy, presentation, and completeness. Wrong garnish? Sent back. Missing side? Caught before the customer sees it.
        </p>
        <p>
          In AI workflows, the expo is <strong>you</strong>. After the final station produces output, you verify it before anyone else sees it:
        </p>
        <ul>
          <li><strong>Does it match the original request?</strong> Not what the model decided you meant—what you actually asked for.</li>
          <li><strong>Are the facts checkable?</strong> Any specific claims, statistics, or references should be verifiable from real sources.</li>
          <li><strong>Did anything get lost between stations?</strong> Compare the final output against earlier station outputs. Did the summary drop an action item? Did formatting swallow a data point?</li>
          <li><strong>Is the quality of the work sufficient?</strong> If not, it's not done.</li>
        </ul>
        <p>
          The expo pass isn't an optional step for cautious people. It's the step that makes everything before it worth doing. A kitchen that sends out unchecked plates will eventually send out something inedible—and an AI workflow that skips verification will eventually produce something inaccurate, embarrassing, or worse.
        </p>

        <h3>Agents: when the kitchen runs itself (mostly)</h3>
        <p>
          You may have heard the term <strong>AI agent</strong>—a system where the model doesn't just respond to a single prompt but actively plans, uses tools, and executes multiple steps on its own. Think of it as upgrading from a single cook who waits for orders to a small crew that can coordinate stations without you calling out every ticket.
        </p>
        <p>
          Agent capabilities are expanding rapidly: coding assistants that read files, write code, and run tests in sequence. Research tools that search the web, synthesize sources, and draft reports. Workflow tools that create project plans, draft communications, and schedule follow-ups—all from a single high-level instruction.
        </p>
        <p>
          This is powerful. It's also not magic. An agent is still running the same station-by-station workflow—it just handles the handoffs automatically instead of requiring you to copy-paste between prompts. The fundamental limits haven't changed:
        </p>
        <ul>
          <li>The context window is still finite. Agents manage it more efficiently, but they don't eliminate it.</li>
          <li>Hallucinations still happen. Agents with tool access hallucinate less, but not zero.</li>
          <li>Drift still compounds. A 15-step agent workflow can drift just like a 15-message conversation.</li>
          <li>Experience is still mandatory. Agents are fallible, so experience is needed for tighter prompts and reliable verification.</li>
        </ul>
        <p>
          The difference between using an agent well and using one poorly is the same as everything else in this guide: <strong>you're still the expediter</strong>. You set the objectives. You define the constraints. You check the output before it ships. The agent runs the line—you run the kitchen.
        </p>

        <details class="tip">
          <summary><strong>Power-up (optional): Tools—the pantry, the cookbook, and the torch</strong></summary>
          <p>
            Throughout this guide we've mentioned that some models can "look things up" or "use tools." Here's what that actually means under the hood.
          </p>
          <p>
            A base LLM can only work with what's already on the prep counter—your prompt, the conversation history, and whatever fits in the context window. <strong>Tools</strong> give the chef access to things beyond the counter: a pantry to grab fresh ingredients (file uploads, databases), a cookbook to look up recipes (web search, retrieval), or a specialized appliance like a brûlée torch (code execution, image generation, API calls).
          </p>
          <p>
            Mechanically, tool use works like this:
          </p>
          <ol>
            <li>The model decides it needs something it doesn't have and generates a structured request—essentially saying "I need to search for X" or "run this code."</li>
            <li>The system (not the model) executes that request: runs the search, executes the code, reads the file.</li>
            <li>The result gets placed back on the prep counter as new context, and the model continues generating with that information available.</li>
          </ol>
          <p>
            Common tool categories:
          </p>
          <ul>
            <li><strong>Search / browsing:</strong> The chef checks a cookbook or calls a supplier. Grounds responses in current, external information instead of relying on training memory alone.</li>
            <li><strong>Code execution:</strong> The chef fires up an appliance—running Python, doing math, processing data. The model writes the code; a sandbox executes it and returns results.</li>
            <li><strong>File reading:</strong> You hand the chef a document, spreadsheet, or image. The contents get placed on the counter as context for the model to work with.</li>
            <li><strong>APIs and plugins:</strong> The chef can call external services—check a calendar, query a database, send a message. Each integration extends what the kitchen can do without the chef needing to know how to build those systems.</li>
            <li><strong>Image generation:</strong> A separate specialist (a different model) that the chef can hand off to—"make this look like X." The chef writes the brief; the specialist produces the visual.</li>
          </ul>
          <p>
            The critical thing to understand: <strong>every tool result lands on the counter and takes up space</strong>. A web search that returns ten paragraphs of results eats the same context window as ten paragraphs of conversation. Tools expand what the chef can <em>access</em>, but they don't expand the counter itself.
          </p>
          <p>
            Tools also don't eliminate hallucinations—they reduce them. The chef can now check the cookbook, but can still misread the page, summarize it incorrectly, or mix up two recipes. Tool access makes the chef more capable, not infallible.
          </p>
        </details>

        <details class="tip">
          <summary><strong>TL;DR</strong></summary>
          <ul>
            <li>Complex tasks break down in a single prompt. Break them into focused stations, each with one job and clear input/output.</li>
            <li>The output of each station becomes the input for the next. Check quality at every handoff—don't blindly pass output forward.</li>
            <li>The <strong>expo pass</strong> is the final verification step. Nothing should leave your workflow without being checked against the original request.</li>
            <li><strong>Agents</strong> automate multi-step workflows but the same limits apply: finite context, possible hallucinations, potential drift.</li>
            <li>Whether you're running stations manually or delegating to an agent, you're still the expediter. Set objectives, define constraints, verify output.</li>
          </ul>
        </details>
      </section>

	      <section>
	        <h2>Choose Your Chef</h2>
	        <p>
	          Now that you know how the kitchen works, it's time to meet the roster. Each model has different strengths, weaknesses, and wildly overdramatic cooking styles—and the right pick depends on what you're making (and what kitchen you're in).
	        </p>

	        <div class="sandbox-card" id="chefSelect">
	          <label class="sandbox-label"><strong>Select your chef</strong></label>
	          <div class="select-screen">
	            <div class="portrait-row" id="csRoster"></div>
	            <div class="chef-panel" id="csPanel">
	              <div class="chef-art" id="csArt"></div>
	              <div class="chef-info" id="csInfo"></div>
	            </div>
	          </div>
	        </div>

	        <div class="truth"><strong>Kitchen truth:</strong> There's no single best chef. The right pick depends on the dish—and the best cooks know when to switch stations.</div>
	      </section>
      <footer class="sub glass">
        <span>© 2026 – Demystifying AI: Stepping into the LLM Kitchen by Chris Yasuda Drysdale</span>
      </footer>

    </main>
  </div>

  <button id="tocFab" class="toc-fab" aria-controls="tocList" aria-expanded="false"
    aria-label="Open table of contents">☰ Inventory</button>
  <a id="toTop" href="#top" title="Back to top">&#8593;</a>

  <script>
    // Station Ticket Builder (Handoff Card)
    (() => {
      const root = document.getElementById('handoffBuilder');
      if (!root) return;

      const what = document.getElementById('hbWhat');
      const facts = document.getElementById('hbFacts');
      const assumptions = document.getElementById('hbAssumptions');
      const missing = document.getElementById('hbMissing');
      const next = document.getElementById('hbNext');
      const btn = document.getElementById('hbGenerate');
      const out = document.getElementById('hbOut');

      if (!what || !facts || !assumptions || !missing || !next || !btn || !out) return;

      const lines = (v) => (v || '')
        .split('\n')
        .map(s => s.trim())
        .filter(Boolean)
        .map(s => `* ${s}`)
        .join('\n');

      function build() {
        const card =
`**HANDOFF CARD**

**What this is:** ${what.value.trim() || '…'}

**Known-good facts (confirmed):**
${lines(facts.value) || '* …'}

**Assumptions (quarantined):**
${lines(assumptions.value) || '* …'}

**MISSING INFO / NEEDS TOOL CHECK:**
${lines(missing.value) || '* …'}

**Next station goal:** ${next.value.trim() || '…'}
`;
        out.textContent = card;
      }

      btn.addEventListener('click', build);
    })();

    // Predict-like-a-phone game
    (() => {
      const game = document.getElementById('predictGame');
      if (!game) return;

      const rounds = [
        {
          s: 'I need to go to the ___',
          c: ['store', 'quantum', 'briefly'],
          p: 0, b: 0,
          e: 'For common phrases, simple prediction nails it. "To the" \u2192 "store" is one of the most frequent word pairings in English.'
        },
        {
          s: 'The surgeon carefully picked up the ___',
          c: ['phone', 'scalpel', 'kids'],
          p: 0, b: 1,
          e: 'Your phone sees "up the" and guesses "phone"\u2014a common pairing. An LLM sees "surgeon" earlier on the counter and picks "scalpel."'
        },
        {
          s: 'After years of studying marine biology, she finally got to swim with the ___',
          c: ['flow', 'kids', 'dolphins'],
          p: 1, b: 2,
          e: '"Marine biology" is 9 words back\u2014far beyond the phone\u2019s window, but easily within an LLM\u2019s counter space.'
        },
        {
          s: 'Of all the planets in our solar system, Jupiter is the ___',
          c: ['planet', 'same', 'largest'],
          p: 1, b: 2,
          e: 'Your phone sees "is the" and suggests "same"\u2014one of the most common bigrams in English. An LLM connects "planets," "solar system," and "Jupiter" to pick "largest."'
        }
      ];

      let cur = 0;
      let done = false;

      const sentenceEl = game.querySelector('#pgSentence');
      const choicesEl = game.querySelector('#pgChoices');
      const revealEl = game.querySelector('#pgReveal');
      const nextBtn = game.querySelector('#pgNext');
      const progressEl = game.querySelector('#pgProgress');

      function render() {
        const r = rounds[cur];
        done = false;
        sentenceEl.textContent = r.s;
        choicesEl.innerHTML = '';
        revealEl.style.display = 'none';
        nextBtn.style.display = 'none';
        progressEl.textContent = 'Round ' + (cur + 1) + ' of ' + rounds.length;

        r.c.forEach((word, i) => {
          const btn = document.createElement('button');
          btn.className = 'sandbox-btn';
          btn.textContent = word;
          btn.type = 'button';
          btn.addEventListener('click', () => pick(i));
          choicesEl.appendChild(btn);
        });
      }

      function pick(idx) {
        if (done) return;
        done = true;
        const r = rounds[cur];

        const btns = choicesEl.querySelectorAll('button');
        btns.forEach((btn, i) => {
          btn.disabled = true;
          if (i === r.b) {
            btn.style.outline = '2px solid var(--accent)';
            btn.style.outlineOffset = '2px';
          }
        });

        let html = '';
        if (r.p === r.b) {
          html += '<p style="margin:0"><strong>Phone suggestion: ' + r.c[r.p] + '</strong>\u2014matches the context-aware pick this time.</p>';
        } else {
          html += '<p style="margin:0"><strong>Phone suggestion:</strong> ' + r.c[r.p] + ' &nbsp;|&nbsp; <strong>Context-aware pick:</strong> ' + r.c[r.b] + '</p>';
        }
        html += '<p class="note" style="margin:.5rem 0 0">' + r.e + '</p>';

        if (cur >= rounds.length - 1) {
          html += '<p style="margin:.8rem 0 0"><strong>Takeaway:</strong> Simple prediction matches common patterns. LLMs use attention to match meaning\u2014which is why they\u2019re dramatically better, but still one token at a time.</p>';
        }

        revealEl.innerHTML = html;
        revealEl.style.display = 'block';

        if (cur < rounds.length - 1) {
          nextBtn.style.display = 'inline-block';
        }
      }

      nextBtn.addEventListener('click', () => {
        cur++;
        render();
      });

      render();
    })();

    // Temperature demo slider
    (() => {
      const slider = document.getElementById('tempSlider');
      const output = document.getElementById('tempOutput');
      const label  = document.getElementById('tempValue');
      if (!slider || !output || !label) return;

      const tiers = [
        [12,  ' blue'],
        [25,  ' clear and cloudless'],
        [37,  ' a deep, brilliant blue that makes the whole city look painted'],
        [50,  ' an ocean flipped upside down, restless and wide'],
        [62,  ' humming with colors that haven\'t been named yet'],
        [75,  ' bargaining with the sea over who gets to keep the color indigo'],
        [87,  ' a cathedral ceiling, echoing with wind'],
        [99,  ' a slow-breathing gradient, deepening toward dusk'],
        [100, ' melting into purple dreams, gathering passing secrets in invisible hands']
      ];

      slider.addEventListener('input', () => {
        const v = +slider.value;
        label.textContent = 'Temperature: ' + (v / 50).toFixed(1);
        const tier = tiers.find(t => v <= t[0]) || tiers[tiers.length - 1];
        output.textContent = tier[1];
      });
    })();

    // Context overflow demo
    (() => {
      const demo = document.getElementById('overflowDemo');
      if (!demo) return;

      const bar = document.getElementById('ofBar');
      const addBtn = document.getElementById('ofAdd');
      const resetBtn = document.getElementById('ofReset');
      const status = document.getElementById('ofStatus');
      const reveal = document.getElementById('ofReveal');

      const MAX = 8;
      let items = [];
      let msgCount = 0;
      let rulesDropped = false;

      function render() {
        bar.innerHTML = '';
        for (let i = 0; i < MAX; i++) {
          const el = document.createElement('div');
          if (i < items.length) {
            el.className = 'counter-slot' + (items[i].type === 'rules' ? ' rules' : ' filled');
            el.textContent = items[i].label;
          } else {
            el.className = 'counter-slot empty';
          }
          bar.appendChild(el);
        }
        status.textContent = items.length + ' / ' + MAX + ' slots used';
      }

      function init() {
        items = [{ label: 'Your rules', type: 'rules' }];
        msgCount = 0;
        rulesDropped = false;
        reveal.style.display = 'none';
        addBtn.disabled = false;
        render();
      }

      addBtn.addEventListener('click', () => {
        msgCount++;
        if (items.length >= MAX) {
          const removed = items.shift();
          if (removed.type === 'rules' && !rulesDropped) {
            rulesDropped = true;
            reveal.innerHTML = '<p style="margin:0"><strong>Your original rules just fell off the counter.</strong></p><p class="note" style="margin:.5rem 0 0">The model has no idea they ever existed. This is forgetting\u2014not drift, not inattention. The instructions are physically gone.</p>';
            reveal.style.display = 'block';
          }
        }
        items.push({ label: 'Msg ' + msgCount, type: 'msg' });
        render();
        if (msgCount >= MAX + 5) addBtn.disabled = true;
      });

      resetBtn.addEventListener('click', init);
      init();
    })();

    // Hallucination quiz
    (() => {
      const quiz = document.getElementById('hallucinationQuiz');
      if (!quiz) return;

      const rounds = [
        {
          claim: 'The average person swallows approximately eight spiders per year while sleeping.',
          fact: false,
          e: 'This "fact" was fabricated in a 1993 magazine column to demonstrate how easily misinformation spreads. Spiders avoid sleeping humans. But it appears so widely online that models reproduce it confidently.'
        },
        {
          claim: 'A group of flamingos is called a "flamboyance."',
          fact: true,
          e: 'Correct\u2014like "a murder of crows" or "a parliament of owls." It sounds made up, which is the point: how plausible something sounds tells you nothing about whether it\u2019s true.'
        },
        {
          claim: 'Goldfish have a memory span of approximately three seconds.',
          fact: false,
          e: 'Goldfish can retain learned behaviors for months and navigate mazes. This myth is so widespread that models often state it as fact without any hedging.'
        },
        {
          claim: 'Bananas are technically classified as berries, but strawberries are not.',
          fact: true,
          e: 'Botanically correct. Berries develop from a single ovary\u2014bananas qualify, strawberries don\u2019t. LLMs get this right because it\u2019s well-represented in training data.'
        }
      ];

      let cur = 0;
      let done = false;
      let score = 0;

      const claimEl = document.getElementById('hqClaim');
      const factBtn = document.getElementById('hqFact');
      const mythBtn = document.getElementById('hqMyth');
      const revealEl = document.getElementById('hqReveal');
      const nextBtn = document.getElementById('hqNext');
      const progressEl = document.getElementById('hqProgress');

      function render() {
        done = false;
        claimEl.textContent = '\u201c' + rounds[cur].claim + '\u201d';
        revealEl.style.display = 'none';
        nextBtn.style.display = 'none';
        factBtn.disabled = false;
        mythBtn.disabled = false;
        factBtn.style.outline = '';
        mythBtn.style.outline = '';
        progressEl.textContent = 'Claim ' + (cur + 1) + ' of ' + rounds.length;
      }

      function pick(answeredFact) {
        if (done) return;
        done = true;
        const r = rounds[cur];
        const correct = answeredFact === r.fact;
        if (correct) score++;

        factBtn.disabled = true;
        mythBtn.disabled = true;

        const rightBtn = r.fact ? factBtn : mythBtn;
        rightBtn.style.outline = '2px solid var(--accent)';
        rightBtn.style.outlineOffset = '2px';

        let html = '<p style="margin:0">';
        html += correct ? '<strong>Correct!</strong> ' : '<strong>Not quite.</strong> ';
        html += 'This is <strong>' + (r.fact ? 'a real fact' : 'a common myth') + '</strong>.</p>';
        html += '<p class="note" style="margin:.5rem 0 0">' + r.e + '</p>';

        if (cur >= rounds.length - 1) {
          html += '<p style="margin:.8rem 0 0"><strong>Result: ' + score + ' / ' + rounds.length + '.</strong> ';
          if (score === rounds.length) {
            html += 'Nice work\u2014but in practice there\u2019s no "Fact or Myth" button. Every AI claim arrives in the same confident voice.';
          } else {
            html += 'That\u2019s the point. Every claim used the same confident tone. The myths were structurally identical to the real facts.';
          }
          html += '</p>';
        }

        revealEl.innerHTML = html;
        revealEl.style.display = 'block';

        if (cur < rounds.length - 1) {
          nextBtn.style.display = 'inline-block';
        }
      }

      factBtn.addEventListener('click', () => pick(true));
      mythBtn.addEventListener('click', () => pick(false));
      nextBtn.addEventListener('click', () => { cur++; render(); });

      render();
    })();

    // Prompt iteration demo
    (() => {
      const demo = document.getElementById('iterationDemo');
      if (!demo) return;

      const steps = [
      {
        prompt: 'Write me an email about the product update.',
        output:
          'Subject: Product Update\n\nHi there,\n\nI wanted to share a quick update about our product. We\u2019ve been working hard and have made some exciting improvements. More details coming soon... hopefully.\n\nLet me know if you have any questions.\n\nBest,\n[Company name]',
        notice:
          '<strong>The problem:</strong> The LLM had almost nothing to work with, so the output is generic filler. It contains no actual product details, no hook, and no reason to buy. But notice\u2014the email <em>looks</em> professional and well-structured. If you weren\u2019t paying attention, you might actually send this and wonder why nobody clicked.'
      },
      {
        prompt:
          'Write a marketing email announcing the iRock Pro MAX+ pet rock. It now has integrated AI features and voice commands. Mention rock-solid answers and that pre-orders are open.',
        output:
          'Subject: Introducing iRock Pro MAX+ \u2014 Your Pet Rock, Now with AI\n\nHi there,\n\nWe\u2019re excited to introduce the iRock Pro MAX+, a pet rock with integrated AI features. It offers rock-solid answers and voice command support.\n\nPre-orders are now open. If you\u2019d like to be among the first to experience a smarter pet rock, reserve yours today.\n\nBest,\n[Company name]',
        notice:
          '<strong>Better:</strong> Now the email has <em>some</em> real content because the prompt provided actual features and a basic CTA. But the tone is still generic and there\u2019s no offer, urgency, or specific feature framing (why should anyone care about a rock with AI?).'
      },
      {
        prompt:
          'Write a marketing email announcing our new product release.\n\nProduct name: iRock Pro MAX+\nTagline: \u201cAI-POWERED SMART ROCK!\u201d\nTone: sophisticated tech-hype + conversational \nFormat: 3 short paragraphs + a feature bullet list + a clear CTA section.\nInclude features in the attached iRock_Pro_Max_Plus.doc (use the exact phrases at least once).\n\nOffer: 20% off pre-orders with code STONESMART\nDeadline: 11:59PM Friday\nCTA button text (as plain text): [Preorder iRock Pro MAX+]\nAdd the iRock standard disclaimer\nEnd with a \u201cWhat to do next\u201d bullet list (3 bullets).\nInclude the attached hero image at the top.',
        output:
          'Subject: Meet iRock Pro MAX+ \u2014 the AI-POWERED SMART ROCK!'+
          '<img src="../images/iRock-Pro-Max-hero.png" alt="iRock Pro MAX+ email hero image" style="width:100%;border-radius:6px;margin-bottom:8px">'+
          'Hi [first_name],\n\nThe future just landed on your desk. Introducing iRock Pro MAX+, the world\u2019s first pet rock upgraded with cutting edge artificial intelligence. It\u2019s cute, it\u2019s quiet, and it seamlessly connects to your smart home.\n\nPowered by Stone-Cold Intelligence\u2122 and an impressive 3000 petaflops processing, iRock Pro MAX+ delivers rock-solid answers. It also includes Ultra 5G-lithic connectivity plus our proprietary R.O.C.K. (Robotic Optimized Cognitive Kernel) to keep your conversations grounded.\n\nFeatures you never asked for:\n\u2022 Stone-Cold Intelligence\u2122\n\u2022 3000 petaflops processing\n\u2022 Rock-solid answers\n\u2022 Ultra 5G-lithic connectivity\n\u2022 R.O.C.K. (Robotic Optimized Cognitive Kernel)\n\u2022 Voice command enabled\n\u2022 Virtual pet rock mode\n\u2022 Zen mode setting\n\nPre-orders are open now\u2014and for a limited time you can get 20% off with code STONESMART (expires 11:59PM Friday).\n\n[Preorder iRock Pro MAX+]\n\nFine print: AI features vary by subscription tier. Plans start at $29.99/mo for Basic (includes Zen mode)\n\nWhat to do next:\n\u2022 Use code STONESMART to pre-order by 11:59PM Friday\n\u2022 Log in to our app to name your iRock Pro MAX+\n\u2022 Enable Zen mode and experience pure, uninterrupted nothingness\n',
        notice:
          '<strong>Same framework, different story.</strong> The only difference was the ticket: specific product facts, a structured format, and explicit tone produced an email that\u2019s usable. Three prompts, three drafts, one extremely useful rock.'
      }
      ];

      let cur = 0;

      const promptEl = document.getElementById('itPrompt');
      const outputEl = document.getElementById('itOutput');
      const noticeEl = document.getElementById('itNotice');
      const nextBtn = document.getElementById('itNext');
      const progressEl = document.getElementById('itProgress');
      const promptBlock = document.getElementById('itPromptBlock');

      function render() {
        const s = steps[cur];
        progressEl.textContent = 'Draft ' + (cur + 1) + ' of ' + steps.length;
        promptBlock.setAttribute('data-label', 'Order ticket (draft ' + (cur + 1) + '):');
        promptEl.textContent = s.prompt;
        outputEl.innerHTML = s.output.replace(/\n/g, '<br>');
        noticeEl.innerHTML = '<p style="margin:0">' + s.notice + '</p>';
        nextBtn.style.display = cur < steps.length - 1 ? 'inline-block' : 'none';
      }

      nextBtn.addEventListener('click', () => { cur++; render(); });

      render();
    })();

    // Workflow station demo
    (() => {
      const demo = document.getElementById('workflowDemo');
      if (!demo) return;

      const steps = [
        {
          label: 'Station 1: Organize',
          prompt: 'Here are rough notes from today\u2019s product sync. Clean them up: fix shorthand, group related items by topic, and mark action items with \u2192.',
          output: 'DESIGN\n\u2022 Homepage redesign approved \u2014 using Option B (card layout)\n\u2022 Mobile nav needs another round \u2014 Janet reviewing by Thursday\n\nENGINEERING\n\u2022 API migration 80% complete, on track for March 7\n\u2022 Auth module blocked on third-party SDK update\n\u2192 Sam to contact vendor re: SDK timeline (by Wed)\n\nLAUNCH\n\u2022 QA starts Monday \u2014 test plan in Confluence\n\u2192 All leads review QA sections (before Monday standup)\n\u2192 3 volunteers needed for user testing (sign up by EOD Fri)',
          notice: 'This station has one job: organizing raw input. The chef isn\u2019t writing the summary yet\u2014just sorting ingredients so the next station starts clean.'
        },
        {
          label: 'Station 2: Extract',
          prompt: 'From the organized notes above, create two lists: (1) Key decisions, one line each. (2) Action items with owner and deadline.',
          output: 'DECISIONS\n1. Homepage redesign \u2192 Option B (card layout)\n2. Mobile nav deferred for another review round\n3. API migration on track for March 7 deadline\n4. QA testing launches Monday\n\nACTION ITEMS\n\u2022 Sam \u2192 Contact SDK vendor re: timeline (by Wed)\n\u2022 All leads \u2192 Review QA test plan sections (before Mon standup)\n\u2022 TBD \u2192 3 volunteers for user testing (by EOD Fri)',
          notice: 'The chef is working with clean, structured input from Station 1\u2014not the original messy shorthand. Better input at each station means better output at every station.'
        },
        {
          label: 'Station 3: Draft + Expo',
          prompt: 'Write a 3-paragraph stakeholder summary from these decisions and action items. Tone: concise, professional. After the summary, add a "Verify before sending" section listing anything implied but not explicitly confirmed in the original notes.',
          output: 'PRODUCT SYNC \u2014 STAKEHOLDER SUMMARY\n\nThe homepage redesign is moving forward with Option B (card layout). Mobile navigation needs an additional review round; Janet will have feedback by Thursday.\n\nThe API migration is 80% complete, tracking toward March 7. The auth module is blocked by a third-party SDK update\u2014Sam is following up with the vendor by Wednesday.\n\nQA begins Monday. Leads should review their test plan sections before standup. We need three volunteers for user testing by end of day Friday.\n\nVERIFY BEFORE SENDING\n\u2022 Was Option B formally approved or just preferred?\n\u2022 Is March 7 a hard deadline or a target?\n\u2022 Is there a sign-up channel for user testing volunteers?',
          notice: '<strong>Three stations, three focused prompts.</strong> Each received clean input from the previous step, had a single clear job, and produced structured output. The "Verify" section is the expo pass\u2014the chef flagging items for you to check before serving.'
        }
      ];

      let cur = 0;

      const promptEl = document.getElementById('wfPrompt');
      const outputEl = document.getElementById('wfOutput');
      const noticeEl = document.getElementById('wfNotice');
      const nextBtn = document.getElementById('wfNext');
      const progressEl = document.getElementById('wfProgress');
      const promptBlock = document.getElementById('wfPromptBlock');

      function render() {
        const s = steps[cur];
        progressEl.textContent = s.label;
        promptBlock.setAttribute('data-label', s.label + ' \u2014 prompt:');
        promptEl.textContent = s.prompt;
        outputEl.innerHTML = s.output.replace(/\n/g, '<br>');
        noticeEl.innerHTML = '<p style="margin:0">' + s.notice + '</p>';
        nextBtn.style.display = cur < steps.length - 1 ? 'inline-block' : 'none';
      }

      nextBtn.addEventListener('click', () => { cur++; render(); });

      render();
    })();
	    // Chef Select
	    (() => {
	      const root = document.getElementById('chefSelect');
	      if (!root) return;

	      const chefs = [
	        {
	          id: 'claude', name: 'Claude', title: 'The Head Chef of Clarity',
	          img: '../images/character_select/Claude.png',
	          bio: 'Runs a terrifyingly organized kitchen. Labels every jar, writes a prep list for the prep list, and politely refuses to plate substitute ingredients.<br><strong>Best for:</strong> careful reasoning, crisp writing, “make this make sense,” and code-review when you need structure.<br><strong>Watch for:</strong> occasionally trying to turn a simple grilled cheese into a masterpiece.',
	          stats: { PREP: 5, FLAV: 2, HEAT: 1, GEAR: 4, PLAT: 4 }
	        },
	        {
	          id: 'chatgpt', name: 'ChatGPT', title: 'The All-Purpose Line Cook',
	          img: '../images/character_select/ChatGPT.png',
	          bio: 'The reliable generalist who can run three stations and still answer your questions mid-rush.<br><strong>Best for:</strong> conversation, drafting, editing, explaining, brainstorming, and fast iteration when you want a steady back-and-forth.<br><strong>Watch for:</strong> occasionally substituting ingredients without saying anything.',
	          stats: { PREP: 3, FLAV: 4, HEAT: 3, GEAR: 3, PLAT: 3 }
	        },
	        {
	          id: 'gemini', name: 'Gemini', title: 'The Multimodal Caterer',
	          img: '../images/character_select/Gemini.png',
	          bio: 'Shows up with a banquet cart of modalities.<br><strong>Best for:</strong> “here\u2019s a screenshot / table / doc\u2014tell me what matters,” research-y synthesis, and anything that mixes formats.<br><strong>Watch for:</strong> the occasional experimental garnish\u2014do an expo pass before it leaves the kitchen.',
	          stats: { PREP: 4, FLAV: 2, HEAT: 3, GEAR: 5, PLAT: 2 }
	        },
	        {
	          id: 'copilot', name: 'Copilot', title: 'The Prep Cook Living in the Walls',
	          img: '../images/character_select/CoPilot.png',
	          bio: 'All the tools and always embedded in your IDE, your browser, your docs.  Not the flashiest chef on the line, but always ready to support with its signature move: auto-complete.<br><strong>Best for:</strong> staying in flow while you live in Microsoft-land and getting quick support on the boring parts.<br><strong>Watch for:</strong> improvisation of the menu when overwhelmed.',
	          stats: { PREP: 4, FLAV: 3, HEAT: 1, GEAR: 5, PLAT: 3 }
	        },
	        {
	          id: 'grok', name: 'Grok', title: 'The Spicy Special',
	          img: '../images/character_select/Grok.png',
	          bio: 'Brings heat, chaos, and a bottle labeled “DO NOT SHAKE” (it shakes it). Also, an unapologetic fanboy of a certain billionaire, if that\u2019s at all important to the dish you\u2019re ordering.<br><strong>Best for:</strong> big swings, punchy rewrites, and generating lots of options fast when you want spicy ideas more than facts.<br><strong>Watch for:</strong> high variance\u2014it tends to over-season and improvise ingredients. Also, don\u2019t feed it after midnight.',
	          stats: { PREP: 1, FLAV: 5, HEAT: 5, GEAR: 2, PLAT: 3 }
	        },
	        {
	          id: 'llama', name: 'LLaMA', title: 'The Home Kitchen Kit',
	          img: '../images/character_select/LLaMA.png',
	          bio: 'Bring-your-own-stove: beloved for self-hosting, customization, and keeping ingredients in-house.<br><strong>Best for:</strong> privacy-sensitive workflows and “I want control of the kitchen” energy (plus tinkering, tuning, and swapping ingredients).<br><strong>Watch for:</strong> results vary by model/size and setup\u2014your mise en place (prompts, evals, settings, etc.) matters a lot.',
	          stats: { PREP: 5, FLAV: 2, HEAT: 3, GEAR: 5, PLAT: 1 }
	        }
	      ];

	      const rosterEl = document.getElementById('csRoster');
	      const artEl = document.getElementById('csArt');
	      const infoEl = document.getElementById('csInfo');
	      const panelEl = document.getElementById('csPanel');
	      let active = -1;

      function stars(n) {
        return '\u2605'.repeat(n) + '\u2606'.repeat(5 - n);
      }

	      function render() {
	        rosterEl.querySelectorAll('.portrait').forEach((p, i) => {
	          p.classList.toggle('active', i === active && active >= 0);
	        });

	        if (active < 0) {
	          if (panelEl) panelEl.classList.add('placeholder');
	          artEl.innerHTML = '<img class="chef-art-placeholder" src="../images/character_select/Silhouette.png" alt="Generic chef silhouette">';
	          infoEl.innerHTML =
	            '<div class="chef-name">???</div>' +
	            '<div class="chef-title-label">Select your chef</div>' +
	            '<div class="chef-bio"></div>';
	          return;
	        }

	        const c = chefs[active];
	        if (panelEl) panelEl.classList.remove('placeholder');
	        artEl.innerHTML = '<img class="chef-art-img" src="' + c.img + '" alt="' + c.name + ' chef card art">';

	        let html = '<div class="chef-name">' + c.name + '</div>';
	        html += '<div class="chef-title-label">' + c.title + '</div>';
	        html += '<div class="chef-bio">' + c.bio + '</div>';
	        html += '<div class="chef-stats">';
        for (const [key, val] of Object.entries(c.stats)) {
          html += '<div class="stat-row"><span class="stat-label">' + key + '</span><span class="stat-stars">' + stars(val) + '</span></div>';
        }
        html += '</div>';
	        infoEl.innerHTML = html;
	      }

	      const portraits = {
	        claude: '../images/character_select/Claude-portrait.png',
	        chatgpt: '../images/character_select/ChatGPT-portrait.png',
	        gemini: '../images/character_select/Gemini-portrait.png',
	        copilot: '../images/character_select/CoPilot-portrait.png',
	        grok: '../images/character_select/Grok-portrait.png',
	        llama: '../images/character_select/LLama-portrait.png'
	      };

	      chefs.forEach((c, i) => {
	        const btn = document.createElement('button');
	        btn.className = 'portrait';
	        btn.type = 'button';
	        btn.setAttribute('aria-label', 'Select ' + c.name);
	        const img = document.createElement('img');
	        img.src = portraits[c.id];
	        img.alt = c.name;
	        btn.appendChild(img);
	        btn.addEventListener('click', () => { active = i; render(); });
	        rosterEl.appendChild(btn);
	      });

	      render();
	    })();
  </script>
</body>

</html>
